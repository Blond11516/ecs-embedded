:github-address: https://github.com/hazelcast-guides/hazelcast-embedded-kubernetes
:templates-url: https://raw.githubusercontent.com/hazelcast-guides/adoc-templates/master
:hazelcast: Hazelcast IMDG
:framework: ECS

= Getting Started with Embedded Hazelcast on ECS

This guide will get you started to use Embedded Hazelcast on the ECS (both based on EC2 and Fargate) environment.

include::{templates-url}/link-to-repo.adoc[]

== What Youâ€™ll Learn

In this guide, you'll deploy an application with embedded Hazelcast into an ECS cluster. Hazelcast instances from each application replica will automatically discover themselves and form one consistent Hazelcast cluster. Thanks to https://github.com/hazelcast/hazelcast-aws[Hazelcast AWS discovery plugin], there is no static configuration needed.

== Prerequisites

- ~15 minutes
- https://docs.docker.com/install/[Docker] (https://www.docker.com/products/docker-desktop[Docker for Desktop] is good enough)
- AWS Account
- https://aws.amazon.com/cli/[AWS command line tool]
- https://git-scm.com/[Git]
- JDK 1.8+
- Apache Maven 3.2+

== Create an Application

You can embed Hazelcast into any JVM-based application and use any web framework you want. As the sample for this guide, let's use the application from https://github.com/hazelcast-guides/hazelcast-embedded-springboot[Getting Started with Hazelcast using Spring Boot] guide. To download it, execute the following command.

----
git clone https://github.com/hazelcast-guides/hazelcast-embedded-springboot.git
----

== Use Hazelcast AWS ECS Configuration

Hazelcast provides the dedicated https://github.com/hazelcast/hazelcast-aws[Hazelcast AWS plugin] which allows to automatically form Hazelcast cluster in the AWS environment. It supports both EC2 discovery and ECS discovery. To enabled it, use the following Hazelcast configuration.

[source, yaml]
----
hazelcast:
  network:
  	interfaces:
      enabled: true
      interfaces:
        - 10.0.*.*
    join:
      multicast:
        enabled: false
      aws:
        enabled: true
----

Note that you need to change `10.0.*.*` to the VPC you will use for your ECS Tasks. To list all your available VPCs, execute the following command.

----
    $ aws ec2 describe-vpcs --query 'Vpcs[*].[VpcId,CidrBlock]'
    [
        [
            "vpc-0681043d6f49b039a",
            "vpc-0681043d6f49b039a"
        ],
        [
            "vpc-0ae005a4a2835bbb5",
            "172.18.0.0/16"
        ]

    ]
----

For the following steps, let's assume that we use VPC `vpc-0681043d6f49b039a` (CIDR `vpc-0681043d6f49b039a`).


To include this file inside your Spring Boot project, copy it into `hazelcast-embedded-springboot/src/resources/`.

----
cp hazelcast.yaml hazelcast-embedded-springboot/src/main/resources/
----

Now, you can build the project with the following command.

----
mvn package -f hazelcast-embedded-springboot/pom.xml
----

As an output, the JAR file with our application should be created at `hazelcast-embedded-springboot/target/*.jar`.

== Containerize the Application

To containerize the application, you need to have Docker installed. Then, you can use the following `Dockerfile`.

[source, dockerfile]
----
FROM openjdk:8-jre-alpine
COPY hazelcast-embedded-springboot/target/*.jar app.jar
ENTRYPOINT ["java","-jar","app.jar"]
----

In order to build the Docker image, run the following command.

----
docker build -t hazelcastguides/hazelcast-embedded-ecs .
----

If you build the image by yourself, then you need to use your Docker Hub account instead of `hazelcastguides`. Then, you can push the image into your Docker Hub registry with the following command.

----
docker push hazelcastguides/hazelcast-embedded-ecs
----

If you want to use your image in the following steps, please also make sure your Docker Hub registry is public. However, for the purpose of this guide, you can also use the already built `hazelcastguides/hazelcast-embedded-ecs` Docker image.

== Create AWS ECS Cluster

Assuming you have an AWS Account and AWS command line tool configured, you can create an ECS cluster with the following command.

----
$ aws ecs create-cluster --cluster-name test-cluster
{
    "cluster": {
        "clusterArn": "arn:aws:ecs:eu-central-1:665466731577:cluster/test-cluster",
        "clusterName": "test-cluster",
        "status": "ACTIVE",
        "registeredContainerInstancesCount": 0,
        "runningTasksCount": 0,
        "pendingTasksCount": 0,
        "activeServicesCount": 0,
        "statistics": [],
        "tags": [],
        "settings": [
            {
                "name": "containerInsights",
                "value": "disabled"
            }
        ],
        "capacityProviders": [],
        "defaultCapacityProviderStrategy": []
    }
}
----

We will use this cluster for all further steps in this guide.

== Create AWS Security Group

$ aws ec2 create-security-group --group-name hazelcast-security-group --description "Hazelcast Security Group" --vpc-id vpc-0681043d6f49b039a
{
    "GroupId": "sg-0cf1116753b96cdce"
}

aws ec2 authorize-security-group-ingress --group-id sg-0cf1116753b96cdce --protocol tcp --port 5701 --cidr 0.0.0.0/0

That is enough for the Hazelcast communication, however if you also want to play with the Spring Boot service, then you need to whitelist its port `8080`.

aws ec2 authorize-security-group-ingress --group-id sg-0cf1116753b96cdce --protocol tcp --port 8080 --cidr 0.0.0.0/0

== Create IAM Role

Hazelcast ECS Discovery uses AWS API to discover Hazelcast members. That is why we need to grant it certain permissions. Here are the command to create an IAM Role we will later use by ECS Tasks.

----
$ aws iam create-policy --policy-name hazelcast-ecs-policy --policy-document file://policy.json
{
    "Policy": {
        "PolicyName": "hazelcast-ecs-policy",
        "PolicyId": "ANPAZV4HIPQ4QUIH45BXB",
        "Arn": "arn:aws:iam::665466731577:policy/hazelcast-ecs-policy",
        "Path": "/",
        "DefaultVersionId": "v1",
        "AttachmentCount": 0,
        "PermissionsBoundaryUsageCount": 0,
        "IsAttachable": true,
        "CreateDate": "2020-06-29T09:52:05Z",
        "UpdateDate": "2020-06-29T09:52:05Z"
    }
}
----

Note Policy `Arn` from the output as you'll need to use it in the further commands.

----
$ aws iam create-role --role-name hazelcast-ecs-role --assume-role-policy-document file://role-policy.json
{
    "Role": {
        "Path": "/",
        "RoleName": "hazelcast-ecs-role",
        "RoleId": "AROAZV4HIPQ47NJGCHJ2A",
        "Arn": "arn:aws:iam::665466731577:role/hazelcast-ecs-role",
        "CreateDate": "2020-06-29T09:58:06Z",
        "AssumeRolePolicyDocument": {
            "Version": "2012-10-17",
            "Statement": [
                {
                    "Effect": "Allow",
                    "Principal": {
                        "Service": "ecs-tasks.amazonaws.com"
                    },
                    "Action": "sts:AssumeRole"
                }
            ]
        }
    }
}
----

Note Role `Arn` from the output as you'll need to use it in the next steps as `TASK_ROLE_ARN`.

----
aws iam attach-role-policy --role-name hazelcast-ecs-role --policy-arn arn:aws:iam::665466731577:policy/hazelcast-ecs-policy
----

== Configure AWS CloudWatch

If you want to read the application logs from your Application, you need to create AWS CloudWatch Group. Note that this step is not required, but highly recommended. If you skip it, you also need to remove CloudWatch entry from `task-definition.json` in the further step and you won't be able to see any logs from your application.

To create CloudWatch group, execute the following command.

---
aws logs create-log-group --log-group-name /ecs/hazelcast
---

To allow ECS Task to write to CloudWatch Log Group, you also need to create the following ECS Role.

----
$ aws iam create-role --role-name ecs-execution-role --assume-role-policy-document file://role-policy.json
{
    "Role": {
        "Path": "/",
        "RoleName": "ecs-execution-role",
        "RoleId": "AROAZV4HIPQ4SGDIWGYRK",
        "Arn": "arn:aws:iam::665466731577:role/ecs-execution-role",
        "CreateDate": "2020-06-29T10:44:01Z",
        "AssumeRolePolicyDocument": {
            "Version": "2012-10-17",
            "Statement": [
                {
                    "Effect": "Allow",
                    "Principal": {
                        "Service": "ecs-tasks.amazonaws.com"
                    },
                    "Action": "sts:AssumeRole"
                }
            ]
        }
    }
}
----

Note Role `Arn` from the output as you'll need to use in the further steps as `EXECUTION_ROLE_ARN`.

Then, attach `AmazonECSTaskExecutionRolePolicy` to the created role.

----
aws iam attach-role-policy --role-name ecs-execution-role --policy-arn arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy
----

== Create Task Definition

To create ECS Task Definition you need first to update `task-definition.json` with the following values:
* `TASK_ROLE_ARN` - `Arn` of the Role created in the "Create IAM Role" step
* `EXECUTION_ROLE_ARN` - `Arn` of the Role created in the "Configure AWS CloudWatch" step
* (optionally) `awslogs-region` - Region that you use for your CloudWatch and ECS Cluster

---
$ aws ecs register-task-definition --cli-input-json file://task-definition.json
{
    "taskDefinition": {
        "taskDefinitionArn": "arn:aws:ecs:eu-central-1:665466731577:task-definition/hazelcast-embedded:2",
        "containerDefinitions": [
            {
                "name": "hazelcast-embedded",
                "image": "hazelcastguides/hazelcast-embedded-ecs",
                "cpu": 0,
                "portMappings": [],
                "essential": true,
                "environment": [],
                "mountPoints": [],
                "volumesFrom": [],
                "logConfiguration": {
                    "logDriver": "awslogs",
                    "options": {
                        "awslogs-group": "/ecs/hazelcast",
                        "awslogs-region": "eu-central-1",
                        "awslogs-stream-prefix": "ecs"
                    }
                }
            }
        ],
        "family": "hazelcast-embedded",
        "taskRoleArn": "arn:aws:iam::665466731577:role/hazelcast-ecs-role",
        "executionRoleArn": "arn:aws:iam::665466731577:role/ecs-execution-role",
        "networkMode": "awsvpc",
        "revision": 2,
        "volumes": [],
        "status": "ACTIVE",
        "requiresAttributes": [
            {
                "name": "com.amazonaws.ecs.capability.logging-driver.awslogs"
            },
            {
                "name": "ecs.capability.execution-role-awslogs"
            },
            {
                "name": "com.amazonaws.ecs.capability.docker-remote-api.1.19"
            },
            {
                "name": "com.amazonaws.ecs.capability.task-iam-role"
            },
            {
                "name": "com.amazonaws.ecs.capability.docker-remote-api.1.18"
            },
            {
                "name": "ecs.capability.task-eni"
            }
        ],
        "placementConstraints": [],
        "compatibilities": [
            "EC2",
            "FARGATE"
        ],
        "requiresCompatibilities": [
            "FARGATE"
        ],
        "cpu": "256",
        "memory": "1024"
    }
}
---


== Create ECS Service

$ aws ec2 describe-subnets --filter --filters "Name=vpc-id,Values=vpc-0681043d6f49b039a" --query 'Subnets[*].[SubnetId,CidrBlock]'
[
    [
        "subnet-0f042c997bad8e2b9",
        "10.0.1.0/24"
    ]
]

aws ecs create-service --cluster test-cluster --service-name hazelcast-embedded --task-definition hazelcast-embedded --desired-count 3 --launch-type=FARGATE --network-configuration "awsvpcConfiguration={subnets=["subnet-0f042c997bad8e2b9"],securityGroups=["sg-0cf1116753b96cdce"],assignPublicIp=ENABLED}"

$ aws ecs list-tasks --cluster test-cluster --service hazelcast-embedded
{
    "taskArns": [
        "arn:aws:ecs:eu-central-1:665466731577:task/2154b675-df19-459e-a95e-8466f5d4bb59",
        "arn:aws:ecs:eu-central-1:665466731577:task/7c3adb1d-6850-4f86-9eb1-7eed5bc75235",
        "arn:aws:ecs:eu-central-1:665466731577:task/99de6977-949d-489c-9c5a-44c763edfaaf"
    ]
}

----
$ aws logs get-log-events --log-group-name /ecs/hazelcast --log-stream-name ecs/hazelcast-embedded/2154b675-df19-459e-a95e-8466f5d4bb59 --output text --query 'events[*].[message]'
Members {size:3, ver:3} [
        Member [10.0.1.4]:5701 - dae44d3d-882b-4f3a-aff3-09721b737276
        Member [10.0.1.6]:5701 - 3874314e-30f9-4f10-9f7d-11a0a32dc16b
        Member [10.0.1.220]:5701 - 9009d19a-63b1-4e90-b4de-48e877bb7086 this
]
----


== Testing the Application

To test that the application works correctly, you can create a Kubernetes service which load balances the traffic to one of the application replicas.

$ aws ecs list-tasks --cluster test-cluster --service hazelcast-embedded
{
    "taskArns": [
        "arn:aws:ecs:eu-central-1:665466731577:task/2154b675-df19-459e-a95e-8466f5d4bb59",
        "arn:aws:ecs:eu-central-1:665466731577:task/7c3adb1d-6850-4f86-9eb1-7eed5bc75235",
        "arn:aws:ecs:eu-central-1:665466731577:task/99de6977-949d-489c-9c5a-44c763edfaaf"
    ]
}

$ aws ecs describe-tasks --cluster test-cluster --tasks 2154b675-df19-459e-a95e-8466f5d4bb59 7c3adb1d-6850-4f86-9eb1-7eed5bc75235 99de6977-949d-489c-9c5a-44c763edfaaf --query "tasks[*].attachments[*].details"
[
    [
        [
            {
                "name": "subnetId",
                "value": "subnet-0f042c997bad8e2b9"
            },
            {
                "name": "networkInterfaceId",
                "value": "eni-0464651cd2cdf1b45"
            },
            {
                "name": "macAddress",
                "value": "02:e3:4b:c3:53:04"
            },
            {
                "name": "privateIPv4Address",
                "value": "10.0.1.220"
            }
        ]
    ],
    [
        [
            {
                "name": "subnetId",
                "value": "subnet-0f042c997bad8e2b9"
            },
            {
                "name": "networkInterfaceId",
                "value": "eni-061b0e2414cfb1440"
            },
            {
                "name": "macAddress",
                "value": "02:e6:04:12:00:70"
            },
            {
                "name": "privateIPv4Address",
                "value": "10.0.1.4"
            }
        ]
    ],
    [
        [
            {
                "name": "subnetId",
                "value": "subnet-0f042c997bad8e2b9"
            },
            {
                "name": "networkInterfaceId",
                "value": "eni-0050d027099aeb812"
            },
            {
                "name": "macAddress",
                "value": "02:47:51:40:b2:72"
            },
            {
                "name": "privateIPv4Address",
                "value": "10.0.1.6"
            }
        ]
    ]
]


$ aws ec2 describe-network-interfaces --network-interface-ids eni-0050d027099aeb812 eni-061b0e2414cfb1440 eni-0464651cd2cdf1b45 --query "NetworkInterfaces[*].Association.PublicIp"
[
    "3.123.22.224",
    "18.185.12.209",
    "18.184.248.123"
]


----
$ curl --data "key=key1&value=hazelcast" "3.123.22.224:8080/put"
{"value":"hazelcast"}
$ curl "18.185.12.209:8080/get?key=key1"
{"value":"hazelcast"}
----

== Tearing Down the Deployment

To delete the service we created, execute the following commands.

----
aws ecs update-service --service hazelcast-embedded --desired-count 0 --cluster test-cluster
aws ecs delete-service --service hazelcast-embedded --cluster test-cluster
----

In order to delete all other resources we created in the guide, execute the following commands.

---
aws ecs deregister-task-definition --task-definition hazelcast-embedded:1
aws iam detach-role-policy --role-name ecs-execution-role --policy-arn arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy
aws iam delete-role --role-name ecs-execution-role
aws logs delete-log-group --log-group-name /ecs/hazelcast
aws iam detach-role-policy --role-name hazelcast-ecs-role --policy-arn  arn:aws:iam::665466731577:policy/hazelcast-ecs-policy
aws iam delete-role --role-name hazelcast-ecs-role
aws iam delete-policy --policy-arn arn:aws:iam::665466731577:policy/hazelcast-ecs-policy
aws ec2 delete-security-group --group-id sg-0cf1116753b96cdce
aws ecs delete-cluster --cluster test-cluster

---
























== Configure RBAC

https://github.com/hazelcast/hazelcast-kubernetes[Hazelcast Kubernetes discovery plugin] makes calls to Kubernetes API to provide automatic member discovery. Therefore, it needs to have specific ClusterRole rules granted. You can apply the minimal RBAC configuration (for the `default` service account in the `default` namespace) with the following command.

----
kubectl apply -f https://raw.githubusercontent.com/hazelcast/hazelcast-kubernetes/master/rbac.yaml
----

Note that:

- If you use service account other than `default` or namespace other than `default`, you need to modify https://raw.githubusercontent.com/hazelcast/hazelcast-kubernetes/master/rbac.yaml
- If your Kubernetes cluster does not use RBAC, you can skip the "Configure RBAC" step

== Deploy the Application to Kubernetes

Assuming you have a running Kubernetes cluster, you can run the following commands to deploy your application and scale it to 2 replicas.

----
kubectl create deployment my-app --image=hazelcastguides/hazelcast-embedded-kubernetes
kubectl scale deployment my-app --replicas=2
----

Now, if you look into created pods, you should see two replicas of your application.

----
$ kubectl get pods
NAME                      READY   STATUS    RESTARTS   AGE
my-app-86df8b785f-4x9pj   1/1     Running   0          81s
my-app-86df8b785f-h926d   1/1     Running   0          73s
----

In your application logs, you should see that embedded Hazelcast instances formed one cluster together.

----
$ kubectl logs pod/my-app-86df8b785f-4x9pj
...
Members {size:2, ver:2} [
        Member [10.24.1.10]:5701 - a7eb36b6-6d86-4d26-8eb6-47986e46d055 this
        Member [10.24.2.6]:5701 - 9994d6c6-d271-4ddd-9aa9-1ac4767c1a73
]
----

== Testing the Application

To test that the application works correctly, you can create a Kubernetes service which load balances the traffic to one of the application replicas.

----
kubectl create service clusterip my-app --tcp=8080:8080
----

Then, to be able to make calls from your local machine, you can use `port-forward`.

----
kubectl port-forward service/my-app 8080:8080
----

Finally, you can make a REST calls to your application.

----
$ curl --data "key=key1&value=hazelcast" "localhost:8080/put"
{"value":"hazelcast"}
$ curl "localhost:8080/get?key=key1"
{"value":"hazelcast"}

----

== Tearing Down the Deployment

To delete all Kubernetes resources you created, run the following command.

----
kubectl delete deployment/my-app service/my-app
----


